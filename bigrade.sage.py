

# This file was *autogenerated* from the file bigrade.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_5 = Integer(5); _sage_const_4 = Integer(4); _sage_const_7 = Integer(7); _sage_const_1 = Integer(1); _sage_const_8 = Integer(8); _sage_const_9 = Integer(9); _sage_const_10 = Integer(10); _sage_const_6 = Integer(6); _sage_const_0 = Integer(0)
import itertools



# My Macualay2 code
# R = QQ[x_0..x_4,y_0,y_1, Degrees=>{5:{0,1},{1,-2},{1,-3}}]
# f = random({0,2}, R)
# g = random({0,3},R)
# F = y_0 * f + y_1 * g
# J = R/ideal jacobian F
# for p from 0 to 5 list hilbertFunction({p,0}, J)
# basis({0,0}, J)
# basis({1,0}, J)
# basis({2,0}, J)



# Nick's Macaulay2 code
# R = QQ[x_0..x_4,y_0,y_1, Degrees=>{5:{0,1},{1,-2},{1,-3}}]
# f = random({1,0}, R)
# J = R/ideal jacobian f
# for p from 0 to 5 list hilbertFunction({p,0}, J)
# basis({0,0}, J)
# basis({1,0}, J)
# basis({2,0}, J)




# for convenience
# x = gens[0]
# y = gens[1]
# z = gens[2]
# a = gens[3]
# b = gens[4]
# c = gens[5]

# f = a^3+b^3-c^2-x*y*z
# f = x^2 + y^2-z^2
# g = x^3+y^3+z^3

# f_0 = f
# f_1 = g


# poly_list = list(var('f_%d' % i) for i in range(num_poly))


# Z = V(f0,..,fc)
# then canonical bundle of Z w_z \cong O_Z(m) with
# m = sum(di) - n - 1


# J_p,m = H^{n-p,p}_van(X)




# d_i = deg(f_i)

# bigrading is
# deg(x_i) = (0,1)
# deg(y_i) = (1,-deg(f_i))


# number of variables
n = _sage_const_3 

# number of hypersurfaces in complete intersection

num_poly = _sage_const_2 

x_vars = list('x_%d' % i for i in range(n))
y_vars = list('y_%d' % i for i in range(num_poly))

R = PolynomialRing(QQ, names= x_vars + y_vars) # M + F call this S


# J_p,m consists of p copies of y_i and sum_d_i copies of x_j
# maybe compute by first all monomials in J_p,m for fixed p, then finding a basis

f = (_sage_const_5 /_sage_const_4 )*x_0**_sage_const_2 +(_sage_const_3 /_sage_const_7 )*x_0*x_1+(_sage_const_2 /_sage_const_3 )*x_1**_sage_const_2 +_sage_const_4 *x_0*x_2+x_1*x_2+(_sage_const_2 /_sage_const_3 )*x_2**_sage_const_2 +(_sage_const_1 /_sage_const_5 )*x_0*x_3+(_sage_const_1 /_sage_const_7 )*x_1*x_3+x_2*x_3+_sage_const_5 *x_3**_sage_const_2 +(_sage_const_3 /_sage_const_2 )*x_0*x_4+(_sage_const_3 /_sage_const_4 )*x_1*x_4+x_2*x_4+(_sage_const_1 /_sage_const_2 )*x_3*x_4+(_sage_const_1 /_sage_const_2 )*x_4**_sage_const_2 
g = (_sage_const_7 /_sage_const_8 )*x_0**_sage_const_3 +(_sage_const_3 /_sage_const_2 )*x_0**_sage_const_2 *x_1+x_0*x_1**_sage_const_2 +(_sage_const_9 /_sage_const_5 )*x_1**_sage_const_3 +(_sage_const_5 /_sage_const_9 )*x_0**_sage_const_2 *x_2+(_sage_const_4 /_sage_const_9 )*x_0*x_1*x_2+(_sage_const_1 /_sage_const_10 )*x_1**_sage_const_2 *x_2+(_sage_const_7 /_sage_const_9 )*x_0*x_2**_sage_const_2 +x_1*x_2**_sage_const_2 +_sage_const_9 *x_2**_sage_const_3 +(_sage_const_10 /_sage_const_9 )*x_0**_sage_const_2 *x_3+(_sage_const_3 /_sage_const_8 )*x_0*x_1*x_3+(_sage_const_4 /_sage_const_3 )*x_1**_sage_const_2 *x_3+(_sage_const_8 /_sage_const_3 )*x_0*x_2*x_3+_sage_const_2 *x_1*x_2*x_3+(_sage_const_7 /_sage_const_8 )*x_2**_sage_const_2 *x_3+(_sage_const_2 /_sage_const_5 )*x_0*x_3**_sage_const_2 +(_sage_const_10 /_sage_const_7 )*x_1*x_3**_sage_const_2 +(_sage_const_4 /_sage_const_9 )*x_2*x_3**_sage_const_2 +(_sage_const_9 /_sage_const_2 )*x_3**_sage_const_3 +(_sage_const_1 /_sage_const_2 )*x_0**_sage_const_2 *x_4+(_sage_const_3 /_sage_const_2 )*x_0*x_1*x_4+(_sage_const_2 /_sage_const_5 )*x_1**_sage_const_2 *x_4+(_sage_const_1 /_sage_const_3 )*x_0*x_2*x_4+x_1*x_2*x_4+(_sage_const_7 /_sage_const_9 )*x_2**_sage_const_2 *x_4+(_sage_const_3 /_sage_const_2 )*x_0*x_3*x_4+_sage_const_4 *x_1*x_3*x_4+(_sage_const_3 /_sage_const_10 )*x_2*x_3*x_4+(_sage_const_3 /_sage_const_4 )*x_3**_sage_const_2 *x_4+(_sage_const_8 /_sage_const_3 )*x_0*x_4**_sage_const_2 +(_sage_const_3 /_sage_const_7 )*x_1*x_4**_sage_const_2 +(_sage_const_2 /_sage_const_5 )*x_2*x_4**_sage_const_2 +(_sage_const_5 /_sage_const_2 )*x_3*x_4**_sage_const_2 +_sage_const_7 *x_4**_sage_const_3 

B = [_sage_const_1 ,x_0*x_1*x_4*y_1, x_0*x_2*x_4*y_1, x_0*x_3**_sage_const_2 *y_1, x_0*x_3*x_4*y_1, x_0*x_4**_sage_const_2 *y_1, x_1**_sage_const_2 *x_4*y_1, x_1*x_2*x_4*y_1, x_1*x_3**_sage_const_2 *y_1, x_1*x_3*x_4*y_1, x_1*x_4**_sage_const_2 *y_1, x_2**_sage_const_2 *x_3*y_1, x_2**_sage_const_2 *x_4*y_1, x_2*x_3**_sage_const_2 *y_1, x_2*x_3*x_4*y_1, x_2*x_4**_sage_const_2 *y_1, x_3**_sage_const_3 *y_1, x_3**_sage_const_2 *x_4*y_1, x_3*x_4**_sage_const_2 *y_1, x_4**_sage_const_3 *y_1,x_4**_sage_const_6 *y_1**_sage_const_2 ]

f_0 = f; f_1 = g;
poly_list = [f_0,f_1]
d = [_.degree() for _ in poly_list]
m = sum([f.degree() for f in poly_list]) - n #- 1

F = sum([y_vars[i] * poly_list[i] for i in range(num_poly)])
I  = F.jacobian_ideal()
J = R.quotient_ring(I)


gens = R.gens()

x_vars = gens[:n]
y_vars = gens[n:]

def monomial_degree(m):
#   e looks like  [(1, 1, 1, 1, 1)]
    e = m.exponents()[_sage_const_0 ]
#   x_i contribute (0, sum(e[:n]))
#   y_i contribute (sum(e[n:],sum([-poly_list[i].degree() for i in range(num_poly)] ))
    return [sum(e[n:]), sum(e[:n])+sum([-d[i] for i in range(num_poly)] )]

