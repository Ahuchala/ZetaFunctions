

# This file was *autogenerated* from the file controlled.sage
from sage.all_cmdline import *   # import sage library

_sage_const_4 = Integer(4); _sage_const_7 = Integer(7); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1)
from sympy.utilities.iterables import multiset_permutations


use_macaulay = True

n = _sage_const_4  #number of variables
p = _sage_const_7 
prec =_sage_const_4 


# R.<x,y,z> = QQ[]
R = QQ['w, x, y, z']; (w, x, y, z,) = R._first_ngens(4)
# R.<x_0,x_1,x_2,x_3,x_4> = QQ[]

Rgens = R.gens()



# f = x^3 + y^3 + z^3 - x*y*z
# f = (2)*x^3+3*x^2*y+(4)*x*y^2+(5)*y^3+(5)*x^2*z+x*y*z+(7)*y^2*z+(5)*x*z^2+(7)*y*z^2+(1)*z^3
# f = x^6 + y^6 + z^6 - x^4*y*z
# f = x^9 + y^9 + z^9
# f = w^3 + x^3 + y^3 + z^3
# f = w^4 + x^4 + y^4  + z^4
# f = x^2 + x*y + y^2 + z^2
# f= 2*x_0^3+2*x_0*x_1^2+x_1^3+2*x_0^2*x_2-x_0*x_1*x_2+2*x_1^2*x_2+x_0*x_2^2+2*x_1*x_2^2+x_2^3-x_0^2*x_3-x_0*x_1*x_3-x_0*x_2*x_3+x_1*x_2*x_3+2*x_2^2*x_3+x_0*x_3^2-x_1*x_3^2-x_2*x_3^2+2*x_0^2*x_4+2*x_0*x_1*x_4-x_1^2*x_4-2*x_0*x_2*x_4-x_1*x_2*x_4+2*x_2^2*x_4+x_0*x_4^2-x_1*x_4^2-2*x_2*x_4^2
f = w**_sage_const_4 +_sage_const_2 *w*x**_sage_const_3 -_sage_const_2 *x**_sage_const_4 -x**_sage_const_3 *y-x**_sage_const_2 *y**_sage_const_2 -y**_sage_const_4 +w**_sage_const_3 *z-x**_sage_const_3 *z-_sage_const_2 *w**_sage_const_2 *y*z+_sage_const_2 *w*x*y*z-x**_sage_const_2 *y*z-w*y**_sage_const_2 *z+_sage_const_2 *x*y**_sage_const_2 *z-_sage_const_2 *y**_sage_const_3 *z-w**_sage_const_2 *z**_sage_const_2 -_sage_const_2 *w*x*z**_sage_const_2 +x**_sage_const_2 *z**_sage_const_2 -_sage_const_2 *w*y*z**_sage_const_2 +x*y*z**_sage_const_2 +y**_sage_const_2 *z**_sage_const_2 +_sage_const_2 *w*z**_sage_const_3 +_sage_const_2 *x*z**_sage_const_3 -_sage_const_2 *y*z**_sage_const_3 -_sage_const_2 *z**_sage_const_4 
# f = x^3 + y^3 + z^3
I = R.ideal([f.derivative(_) for _ in R.gens()])
J = R.quotient(I)

xI = R.ideal([_*f.derivative(_) for _ in R.gens()])
xJ = R.quotient(xI)

d = f.degree()
fdegree = d

# i.e. y^3 -> [0,3,0,0] when n=4
def monomial_to_vector(m):
    return list(m.exponents()[_sage_const_0 ])

def vector_to_monomial(v):
    return prod([Rgens[i]**v[i] for i in range(n)])

lift_dict = {}
# for l in range(n):
#     if (l*d-n)>=0:
#         print('computing lifts of degree ' + str(l*d-n))
#         for part in Partitions(l*d-n, max_length=n):
#     #       pad with zeros
#             part += [0] * (n - len(part))

#             for perm in multiset_permutations(part):
#                 m = vector_to_monomial(perm)
#     #                 use cached lifts
#                 c = J(m).lift()
#                 r = (m-c).lift(I)
#                 lift_dict[m] = (c,r)

if use_macaulay:
    print('computing lifts of degree ' + str((n-_sage_const_1 )* fdegree - n+d) + ' using macaulay')
    s = ''
    # toString (basis(''' + str((n-1)*d-(n-1)+d) + ''',R) % M), toString (basis(''' + str((n-1)*d-(n-1)+d) + ''',R) // M)
    if n == _sage_const_3 :
        s = macaulay2('''
        R = QQ[x..z]; 
        f = ''' + str(f) + ''';
        M = matrix{ for v in gens R list v*diff(v,f) };
        toString basis(''' + str((n-_sage_const_1 )* fdegree - n+d) + ''',R), toString (basis(''' + str((n-_sage_const_1 )* fdegree - n+d) + ''',R) // M)
        ''')
    elif n == _sage_const_4 :
        s = macaulay2('''
        R = QQ[w..z]; 
        f = ''' + str(f) + ''';
        M = matrix{for v in gens R list v*diff(v,f) };
        toString basis(''' + str((n-_sage_const_1 )* fdegree - n+d) + ''',R), toString (basis(''' + str((n-_sage_const_1 )* fdegree - n+d) + ''',R) // M)
        ''')
    # s = [str(_).replace("matrix {{","").replace("}","") for _ in s]
    # s = ",".join(s)
    s = str(s)
    s = s[_sage_const_1 :-_sage_const_1 ]
    s = s.replace('matrix {{','').replace(' ','')
    b,s = s.split("}}")[:-_sage_const_1 ]
    b = b.split(',')
    # s.split('},{')
    # s = [_.split(',') for _ in s]
    s = s.split('},{')
    s = [_.split(',') for _ in s]
    s[_sage_const_0 ] = s[_sage_const_0 ][_sage_const_1 :]
    for i in range(len(b)):
        lift_dict[R(b[i])] = [R(_[i]) for _ in s]
        # print(b[i],[_[i] for _ in s])
    # print(s)

else:
    print('computing lifts of degree ' + str((n-_sage_const_1 )* fdegree - n+d) + ' using sage')
    for part in Partitions((n-_sage_const_1 )* fdegree -n+d, max_length=n):
    #       pad with zeros
        part += [_sage_const_0 ] * (n - len(part))

        for perm in multiset_permutations(part):
            m = vector_to_monomial(perm)
    #                 use cached lifts
            c = xJ(m).lift()
            r = (m-c).lift(xI)
            lift_dict[m] = r
            

print('computing cohomology basis')
def compute_primitive_cohomology():

#     R = QQ[w..z]
#     f = ...
#     J = R/ideal jacobian f
#     toString basis(4,J)
    B = set()
    for l in range(n):
#         print('computing Jacobian basis of rank ' + str(l*d))
        if (l*d-n)>=_sage_const_0 :
            for part in Partitions(l*d-n, max_length=n):
        #       pad with zeros
                part += [_sage_const_0 ] * (n - len(part))

                for perm in multiset_permutations(part):
                    m = vector_to_monomial(perm)
                    for monomial in J(m).lift():
                        B.add(monomial[_sage_const_1 ])
    #                 use cached lifts
#                     c,r = lift_dict[m]
#                     for monomial in c.monomials():
#                         B.add(monomial)
    return list(B)
B = compute_primitive_cohomology()

print(len(B), (-_sage_const_1 )**(n)*(_sage_const_1 /d * ((_sage_const_1 -d)**(n)-_sage_const_1 )+_sage_const_1 ))


def sigma(g):
    return sum([g.coefficient(monomial)* monomial**p for monomial in g.monomials()])

def frobenius(g,prec=_sage_const_2 ):
#     m = g.degree()//f.degree()
    d = g.degree() // f.degree()
    summer = _sage_const_0 
    sigma_g = sigma(g)
    fj = R(_sage_const_1 )
    for j in range(prec):
#         summer += binomial(-d,j) * binomial(d+N-1,d+j) * sigma(g)*sigma(qf^j)
#         cacheing may be appropriate
        numer = binomial(-d,j) * binomial(d+prec-_sage_const_1 ,d+j) * sigma_g*sigma(fj)
        summer += numer #/(f^(p*(d+j)))
        fj *= f
    return summer

def frobenius_on_cohom(i,prec = _sage_const_2 ):
    g = B[i]*prod(Rgens)
    g = frobenius(g,prec)
    return R(g *p**(n -_sage_const_2 ) / prod(Rgens))

def lift_poly(g):
    summer = n * [_sage_const_0 ]
    for monomial in g.monomials():
        monomial_lift = lift_dict[monomial]
        c = g.monomial_coefficient(monomial)
        for i in range(n):
            summer[i] += c*monomial_lift[i]
    return summer

def Ruv(u,v,g):
    print(u,v,g)
    gi = lift_poly(vector_to_monomial(v)*g)
    deg_g = (n-_sage_const_1 )*fdegree-(n-_sage_const_1 )
    m = (sum(u) +deg_g+ n) // fdegree

#     m = (sum(u) + sum(v) - g.degree() + n-1) // fdegree - 1
#     print(gi)
    h = sum([(u[i] +_sage_const_1 )*gi[i] + Rgens[i] * (gi[i]).derivative(Rgens[i]) for i in range(n)])
    v = n * [_sage_const_0 ]
    for i in range(n):
        while u[i] > _sage_const_0 :
            u[i] = u[i] - _sage_const_1 
            v[i] = v[i] + _sage_const_1 
            if sum(v) == fdegree:
                return (u,v,h/m)

# this is hacky but only done once per basis element
def to_uvg(h):
    hdict = h.dict()
    return_list = []
    for etuple in hdict.keys():
        vector = list(etuple)
        c = hdict[etuple]
        
#         first check if it's divisible by something in the list
        already_divisible = False
        for j in range(len(return_list)):
            if not already_divisible:
                known_mono_tuple = return_list[j]
                u,v,g = known_mono_tuple
                if sum(u) + fdegree + g.degree() == sum(etuple):
                    if sum([etuple[i] >= u[i] + v[i] for i in range(n)]) == n:
                        g += c * vector_to_monomial([etuple[i] - u[i] - v[i] for i in range(n)])
                        return_list[j] = [u,v,g]
                        already_divisible = True
        if not already_divisible:
    
            
            d = (sum(vector) -n)// f.degree()

            u = n * [_sage_const_0 ]
            v = n * [_sage_const_0 ]

            for i in range(n):
                while vector[i] > _sage_const_0 :
                    vector[i] = vector[i] -_sage_const_1 
                    v[i] = v[i] + _sage_const_1 
                    if sum(v) == fdegree:
                        u = vector
                        vector = n * [_sage_const_0 ]

            g_vec = n * [_sage_const_0 ]
            vector = u
            for i in range(n):
                while vector[i] > _sage_const_0 :
                    vector[i] = vector[i] - _sage_const_1 
                    g_vec[i] = g_vec[i] + _sage_const_1 
                    if sum(g_vec) == (n-_sage_const_1 )* fdegree - n:
                        u = vector
                        vector = n * [_sage_const_0 ]
            g = c * vector_to_monomial(g_vec)
            return_list.append([u,v,g])
    return return_list


reduction_dict = {}

frob_matrix = [[_sage_const_0  for i in range(len(B))] for j in range(len(B))]

# sum([Qx(h).lift(J)[i] * [m  * qf.derivative(xi) for xi in qxgens][i] for i in range(3)]) == Qx(h)
for i in range(len(B)):
    h = frobenius_on_cohom(i,prec)
    print(h)
    htemp = _sage_const_0 
    for u,v,g in to_uvg(h):
        while sum(u) > fdegree:
            u,v,g = Ruv(u,v,g)
        htemp += vector_to_monomial(u) * vector_to_monomial(v) * g
    h = htemp
    
    summer = R(_sage_const_0 )
#   monomials to reduce (with coefficients)
    monomial_list = [R(h.monomial_coefficient(monomial)) * monomial for monomial in h.monomials()]
    while len(monomial_list) > _sage_const_0 :
        term  = monomial_list.pop()
#         print(term,term.monomials()[0])
        if term not in QQ:
            if len(term.monomials())>_sage_const_1 :
                print('error: too many terms')
            monomial = R(term.monomials()[_sage_const_0 ])
            if not monomial in B:
                if not monomial in reduction_dict.keys():
                    q = J(monomial).lift()
                    r = monomial - q
                    l = r.lift(I)
                    m = (monomial.degree() +n)// f.degree()
#                     print(monomial,m)
                    temp = sum([l[i].derivative(Rgens[i]) for i in range(n)])/(m-_sage_const_1 ) #m-1? m+1? coherent for m+1?
                    reduction_dict[monomial] = temp + q
                result = reduction_dict[monomial]
                for _ in result.monomials():
                    monomial_list.append(_*term.monomial_coefficient(monomial) * result.monomial_coefficient(_))
            else:
                summer += term.monomial_coefficient(monomial) * monomial
        else:
            summer += term
    
    for j in range(len(B)):
        frob_matrix[i][j] = summer.monomial_coefficient(R(B[j])) % p**prec
        
    print(B[i],summer)

frob_matrix = matrix(frob_matrix)
print(frob_matrix)
print(frob_matrix.characteristic_polynomial() %p**(prec))

poly = R(frob_matrix.characteristic_polynomial())
print(poly)
poly = sum([(poly.monomial_coefficient(mono) % p**(prec) )* mono if (poly.monomial_coefficient(mono)% p**prec) < (p**prec)//_sage_const_2  else (-p**(prec)+poly.monomial_coefficient(mono)% p**prec)*mono for mono in poly.monomials()])
print(poly)

for r in range(_sage_const_1 ,len(B)+_sage_const_1 ):
    print(sum([p**(_*r) for _ in range(_sage_const_3 )]) + (-_sage_const_1 )**n * (frob_matrix**r).trace())

