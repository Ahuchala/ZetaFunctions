

# This file was *autogenerated* from the file zetaCI.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_7 = Integer(7); _sage_const_1 = Integer(1); _sage_const_3 = Integer(3); _sage_const_4 = Integer(4); _sage_const_0 = Integer(0); _sage_const_999999999 = Integer(999999999)#########################################################
# Refactored Sage code for computing the Hasse-Weil
# zeta function of a smooth complete intersection over F_p
# via p-adic approximation of Frobenius in a Griffiths-
# type Jacobian ring.
#########################################################

# If your environment allows, you might rename this file "hasse_weil_zeta.sage"
# and load it from a Sage session.

# Remove or set to True if you need it:
USE_CYTHON = False

# Number of hypersurfaces in the complete intersection
num_poly = _sage_const_2 

# Prime and precision
p = _sage_const_7 
prec = _sage_const_2 

#########################################################
# Load any external code if needed
#########################################################
load("mat_mul.sage")  # Provided by your environment

#########################################################
# Create polynomial ring in Sage
#########################################################
R = QQ['x_0, x_1, x_2, x_3, y_1, y_2']; (x_0, x_1, x_2, x_3, y_1, y_2,) = R._first_ngens(6)# Example ring
gens = R.gens()

n = len(gens) - num_poly - _sage_const_1   # x-vars: n+1, y-vars: num_poly
assert len(gens) == num_poly + n + _sage_const_1 

x_vars = gens[: n + _sage_const_1 ]
y_vars = gens[n + _sage_const_1  :]

#########################################################
# Example polynomials f, g for a complete intersection
#########################################################
# You can replace these with your own desired polynomials.
f = sum([gen**_sage_const_2  for gen in x_vars])
g = x_0**_sage_const_2  + _sage_const_2 *x_1**_sage_const_2  + _sage_const_3 *x_2**_sage_const_2  + _sage_const_4 *x_3**_sage_const_2 

poly_list = [f] if num_poly == _sage_const_1  else [f, g]
d = [_.degree() for _ in poly_list]  # degrees of each polynomial
m = sum(d) - n - _sage_const_1 

# Construct F = sum(y_i * f_i)
F = sum([y_vars[i] * poly_list[i] for i in range(num_poly)])

# Basic check: ensure p is prime
assert p in Primes(), f"Warning: {p} is not prime."

#########################################################
# Helper routines
#########################################################
def monomial_to_vector(m):
    """
    Convert monomial m in R to exponent vector.
    """
    return list(m.exponents()[_sage_const_0 ])

def vector_to_monomial(v):
    """
    Convert exponent vector v back to monomial in R.
    """
    return prod([gens[i]**v[i] for i in range(len(gens))])

def pole_order(m):
    """
    Returns how many times F appears in the denominator.
    For monomial m = x^u * y^w, the exponent sum in y_i's
    is the 'pole order'.
    """
    e = m.exponents()[_sage_const_0 ]
    return sum(e[n+_sage_const_1 :])

def sigma(g):
    """
    Frobenius endomorphism:
    x_i -> x_i^p for each monomial x^e -> x^(p e).
    """
    g_dict = g.dict()
    new_dict = {}
    for exps, coeff in g_dict.items():
        # exps -> (p * exps)
        new_exps = tuple(e * p for e in exps)
        new_dict[new_exps] = coeff
    return R(new_dict)

def frobenius(g_in, prec=_sage_const_2 ):
    """
    Compute the Frobenius action on a 'logarithmic form' g / F^d, expanded up to F^prec.
    g_in is a polynomial in R, with some negative powers of F if needed.
    """
    dord = pole_order(g_in)
    accum = _sage_const_0 
    sig_g = sigma(g_in)
    fpow = R(_sage_const_1 )
    for j in range(prec):
        # Binomial expansions for (1 + F + ...)^(-d), etc.
        coeff = binomial(-dord, j) * binomial(dord + prec - _sage_const_1 , dord + j)
        accum += coeff * sig_g * sigma(fpow)
        fpow *= F
    return accum

def frobenius_on_cohom(i, prec=_sage_const_2 ):
    """
    Apply Frobenius to B[i], where B is the Griffiths ring basis.
    In the user code, we multiply by prod(x_i) to shift degrees,
    then apply Frobenius, then shift back.
    """
    g_temp = R(B[i]) * prod(gens)
    g_temp = frobenius(g_temp, prec)
    # multiply by p^(n-1) / (product of x_i)
    return R(g_temp * (p**(n - _sage_const_1 )) / prod(gens))

#########################################################
# Macaulay2 checks and basis computations
#########################################################
# Check smoothness in Macaulay2
# This code depends on your local Macaulay2 environment.
check_smooth_m2 = f"""
k = ZZ/{p};
R = k[x_0..x_{n}];
I = ideal {str(tuple(poly_list))[:-_sage_const_2 ] if len(poly_list) == _sage_const_1  else str(tuple(poly_list))[:-_sage_const_1 ]};
J = I + minors({num_poly}, jacobian I);
saturate J == R
"""
#assert str(macaulay2(check_smooth_m2)) == "true", f"Warning: F not smooth modulo {p}"

# Compute Macaulay2 basis B for H^{n-p,p}_van
# (We parse the result that M2 prints out.)
compute_B_m2 = f"""
k = ZZ/{p};
R = k[x_0..x_{n}, y_1..y_{num_poly},
       Degrees => {{{n+_sage_const_1 }:{{0,1}},
                    {str([(_sage_const_1 , -dd) for dd in d])[_sage_const_1 :-_sage_const_1 ].replace('(','{').replace(')','}')}}}];
F = {sum([y_vars[i]*poly_list[i] for i in range(num_poly)])};
J = R/ideal jacobian F;
for i from 0 to {n - num_poly} list toString basis({{i,{m}}}, J)
"""
Braw = str(macaulay2(compute_B_m2))
Braw = Braw.replace("{","").replace("}","").replace("^","**").replace(" ","").split("matrix")[_sage_const_1 :]
Braw = "".join(Braw).split(",")
B = []
for entry in Braw:
    if entry != "":
        # Evaluate in the Sage ring R
        eval("B.append(R(" + entry + "))")

max_cohomology_pole_order = max([pole_order(_) for _ in B])
size_B = len(B)

# Compute basis P1 (the bigrading {1,0}).
# Typically used in the Griffiths reduction steps.
compute_P1_m2 = f"""
k = ZZ/{p};
R = k[x_0..x_{n}, y_1..y_{num_poly},
       Degrees => {{{n+_sage_const_1 }:{{0,1}},
                    {str([(_sage_const_1 , -dd) for dd in d])[_sage_const_1 :-_sage_const_1 ].replace('(','{').replace(')','}')}}}];
toString basis({{1,{_sage_const_0 }}}, R)
"""
P1raw = str(macaulay2(compute_P1_m2))
P1raw = P1raw.replace("{","").replace("}","").replace("^","**").replace(" ","").split("matrix")[_sage_const_1 :]
P1raw = "".join(P1raw).split(",")
P1 = []
P1_pts = []
for entry in P1raw:
    if entry != "":
        mon = R(entry)
        P1.append(mon)
        P1_pts.append(monomial_to_vector(mon))

# Compute basis Pn (the bigrading {n, -2}), or whichever bigrading you need
compute_Pn_m2 = f"""
k = ZZ/{p};
R = k[x_0..x_{n}, y_1..y_{num_poly},
       Degrees => {{{n+_sage_const_1 }:{{0,1}},
                    {str([(_sage_const_1 , -dd) for dd in d])[_sage_const_1 :-_sage_const_1 ].replace('(','{').replace(')','}')}}}];
toString basis({{{n},{{-2}}}}, R)
"""
Pnraw = str(macaulay2(compute_Pn_m2))
Pnraw = Pnraw.replace("{","").replace("}","").replace("^","**").replace(" ","").split("matrix")[_sage_const_1 :]
Pnraw = "".join(Pnraw).split(",")
Pn = []
Pn_pts = []
for entry in Pnraw:
    if entry != "":
        mon = R(entry)
        Pn.append(mon)
        Pn_pts.append(monomial_to_vector(mon))

size_pn = len(Pn)

#########################################################
# Create quotient ring objects in Sage
#########################################################
I = F.jacobian_ideal()
J = R.quotient_ring(I)

#########################################################
# to_ug: break polynomial into monomials that factor out
# part from Pn
#########################################################
def to_ug(frobenius_of_Bi):
    """
    Splits the polynomial frobenius_of_Bi into a list of [u, g]
    where monomial = x^u * g, with g in Pn.
    """
    result_list = []
    poly_dict = dict(frobenius_of_Bi.dict())
    while poly_dict:
        # Just pick the first monomial in the dict:
        etuple = next(iter(poly_dict))
        coeff  = poly_dict.pop(etuple)
        vector_exp = list(etuple)

        # Find some g in Pn_pts that divides this monomial
        # so that monomial = x^u * g
        for g_vec in Pn_pts:
            # check if g_vec <= etuple in each component
            if all(vector_exp[i] >= g_vec[i] for i in range(len(gens))):
                # factor out g_vec
                u_vec = [vector_exp[i] - g_vec[i] for i in range(len(gens))]
                # Construct the actual polynomial piece
                g_mon = vector_to_monomial(g_vec) * coeff
                result_list.append([u_vec, g_mon])
                break
    return result_list

#########################################################
# PN basis conversions
#########################################################
def to_pn_basis(g_poly):
    """
    Return the coordinate vector of g_poly in the basis Pn.
    """
    coords = [_sage_const_0 ]*(size_pn)
    for monomial in g_poly.monomials():
        idx = Pn.index(monomial)
        coords[idx] = g_poly.monomial_coefficient(monomial)
    return coords

def from_pn_basis(vec):
    """
    Convert a coordinate vector in the basis Pn back to a polynomial in R.
    """
    return sum([vec[i]*Pn[i] for i in range(size_pn)])

#########################################################
# Lifting polynomials
#########################################################
lift_dict = {}
def lift_poly(g_poly):
    """
    Lifts g_poly in J back to R. Uses caching in lift_dict.
    """
    # We'll accumulate in arrays of length (n+num_poly+1).
    out_sums = [_sage_const_0 ]*(n + num_poly + _sage_const_1 )
    for monomial in g_poly.monomials():
        if monomial not in lift_dict:
            # c = J(monomial).lift() is the remainder of 'monomial' in the quotient
            c_quot = J(monomial).lift()
            # r = (monomial - c) mod xI?
            # In your code, xI is something like R.ideal([gen*F.derivative(gen) for gen in gens])
            # but not all references are shown. Make sure xI is globally defined.
            r = (monomial - c_quot).lift(xI)
            # For each i, store that partial
            partial = []
            for i in range(n + num_poly + _sage_const_1 ):
                ri_dict = r[i].dict()
                # reduce mod p^(2+prec) if needed
                for exps_r in ri_dict.keys():
                    ri_dict[exps_r] = ri_dict[exps_r] % p**(_sage_const_2 +prec)
                partial.append(R(ri_dict))
            lift_dict[monomial] = partial

        c_coeff = g_poly.monomial_coefficient(monomial)
        mon_lift = lift_dict[monomial]
        # accumulate
        for i in range(len(mon_lift)):
            out_sums[i] += c_coeff * mon_lift[i]
    return out_sums

#########################################################
# Ruv data structures
#########################################################
Ruv_const_dict = {}
Ruv_u_dict = {}

def Ruv_const_helper(v, g):
    """
    Compute the portion of Ruv for constant part (the derivative portion).
    """
    # lift x^v * g
    lifted = lift_poly(vector_to_monomial(v)*g)
    # sum of partial derivatives
    h = sum(lifted[i] + gens[i]*(lifted[i].derivative(gens[i])) for i in range(n+num_poly+_sage_const_1 ))
    return vector(to_pn_basis(h))

def Ruv_u_helper(v, g):
    """
    Compute the portion of Ruv for the 'u' part.
    """
    # lift x^v * g
    lifted = lift_poly(vector_to_monomial(v)*g)
    # Return a list of PN-basis vectors for each partial
    return [vector(to_pn_basis(a)) for a in lifted]

def compute_Ruv(v):
    """
    Precompute Ruv for a given v in P1, storing in Ruv_const_dict and Ruv_u_dict.
    """
    Ruv_u_mat = []
    Ruv_const_mat = []
    for i in range(size_pn):
        g = Pn[i]
        tmp_u = Ruv_u_helper(v, g)    # partial for each x_i
        tmp_c = Ruv_const_helper(v,g) # derivative portion
        Ruv_const_mat.append(tmp_c)

        # Insert columns for each i
        if i == _sage_const_0 :
            # Initialize matrix of dimension (n+num_poly+1) x size_pn
            # by building columns
            for row_idx in range(len(tmp_u)):
                Ruv_u_mat.append([_sage_const_0 ]*size_pn)
        for row_idx, row_val in enumerate(tmp_u):
            Ruv_u_mat[row_idx][i] = row_val

    Ruv_const_dict[tuple(v)] = matrix(Ruv_const_mat)  # size_pn x size_pn
    Ruv_u_dict[tuple(v)]    = tuple(matrix(rr) for rr in Ruv_u_mat)  # each is size_pn x size_pn

#########################################################
# VK-based reduction (Griffiths / Dwork)
#########################################################
def compute_vk(u):
    """
    Write u as u' + k*v with v in P1_pts and k maximal
    so that pole_order(x^(u'-k*v)) is still > something, etc.
    Possibly adjust if we overshoot.
    """
    best_k = -_sage_const_1 
    best_v = None
    for v in P1_pts:
        # naive approach: how many times can we subtract v from u
        # in each component
        k = min((u[i] // v[i] if v[i] != _sage_const_0  else _sage_const_999999999 ) for i in range(len(u)))
        if k > best_k:
            best_k = k
            best_v = v
    if best_k < _sage_const_0  or best_v is None:
        return None, _sage_const_0 

    # Some final check for the pole order if needed:
    # Here just return v, k. Adjust if you want to ensure the pole order is correct.
    return best_v, best_k

def reduce_griffiths_dwork(u, g):
    """
    Repeatedly reduce x^u*g to keep the order in the range
    that belongs to the relevant cohomology space.
    """
    g_vec = vector(to_pn_basis(g))

    # Keep reducing while the monomial x^u has a pole order bigger than we allow
    while pole_order(vector_to_monomial(u)) > max_cohomology_pole_order:
        v, k = compute_vk(u)
        if v is None or k <= _sage_const_0 :
            break  # no further reduction possible

        if tuple(v) not in Ruv_u_dict:
            compute_Ruv(v)

        E = Ruv_const_dict[tuple(v)]
        Dtuple = Ruv_u_dict[tuple(v)]
        # Build E + sum(u[i]*Dtuple[i])
        sum_of_uD = matrix.zero(size_pn)
        for i_comp in range(len(u)):
            sum_of_uD += u[i_comp]*Dtuple[i_comp]
        big_E = E + sum_of_uD

        # Build sum(v[i]*Dtuple[i])
        sum_of_vD = matrix.zero(size_pn)
        for i_comp in range(len(u)):
            sum_of_vD += v[i_comp]*Dtuple[i_comp]

        # We multiply g_vec by (E - i*sum_of_vD) repeatedly for i in 0..k-1
        # This matches your "g_vec = mat_mul(E,F,k,g_vec)" logic, i.e. repeated steps.
        # Or do it directly if mat_mul does that in one shot.
        for idx in range(_sage_const_1 , k+_sage_const_1 ):
            # In your code: g_vec *= (E - idx * sum_of_vD) ...
            # Using a matrix approach:
            g_vec = g_vec * (big_E - idx*sum_of_vD)

        # Subtract k * v from u
        u = [u[i] - k*v[i] for i in range(len(u))]

    # Return the final pair
    return u, from_pn_basis(g_vec)

#########################################################
# Main driver: build Frobenius matrix on cohomology
#########################################################
frob_matrix = [[_sage_const_0  for _ in range(size_B)] for __ in range(size_B)]
reduction_dict = {}

for i in range(size_B):
    # Apply Frobenius
    h = frobenius_on_cohom(i, prec)
    new_poly = R(_sage_const_0 )

    # Expand h as sum of x^u*g with g in Pn
    expansions = to_ug(h)
    for (u_vec, g_poly) in expansions:
        denom = factorial(pole_order(vector_to_monomial(u_vec)))  # check if you want + num_poly - 1, etc.
        # Reduce
        final_u, final_g = reduce_griffiths_dwork(u_vec, g_poly)
        # Add to new_poly
        new_poly += (vector_to_monomial(final_u) * final_g) / denom

    # Next reduce new_poly mod B (the basis) fully, ensuring only basis elements remain
    # The code below tries to keep only monomials in B, and everything else is reduced:
    summer = R(_sage_const_0 )
    mon_list = [R(new_poly.monomial_coefficient(m)) * m for m in new_poly.monomials()]

    while mon_list:
        term = mon_list.pop(_sage_const_0 )
        if len(term.monomials()) > _sage_const_1 :
            # Something unusual; skip or break
            continue
        mterm = term.monomials()[_sage_const_0 ]
        coeff = term.monomial_coefficient(mterm)
        if mterm not in B:
            if mterm not in reduction_dict:
                # In your code, you do J(mterm).lift() etc.  We'll mimic:
                q_part = J(mterm).lift()
                r_part = (mterm - q_part)
                lifted_r = r_part.lift(I)
                # Sum of partial derivatives
                red_val = sum(lifted_r[i].derivative(gens[i]) for i in range(n + num_poly + _sage_const_1 ))
                reduction_dict[mterm] = red_val + q_part
            # Multiply the known reduction by the coefficient
            sub_poly = coeff * reduction_dict[mterm]
            # Rebuild mon_list from new "summer + sub_poly"
            new_sum = sum(mon_list) + sub_poly
            mon_list = [R(new_sum.monomial_coefficient(mm))*mm for mm in new_sum.monomials()]
        else:
            summer += term

    # Now summer is in the basis B. Extract coordinates for frob_matrix
    for j in range(size_B):
        # factorial(...) might differ based on your indexing
        # It's from the original code's 'pole_order(B[j])+num_poly -1'
        pm_order = pole_order(B[j]) + num_poly - _sage_const_1 
        c = summer.monomial_coefficient(R(B[j])) * factorial(pm_order)
        frob_matrix[i][j] = c

# Reduce all entries mod p^prec
all_invertible = True
for row_idx in range(size_B):
    for col_idx in range(size_B):
        if frob_matrix[row_idx][col_idx].valuation(p) < _sage_const_0 :
            all_invertible = False
            break
frob_matrix_mod = []
if all_invertible:
    for row in frob_matrix:
        frob_matrix_mod.append([entry % (p**prec) for entry in row])
    frob_matrix = matrix(frob_matrix_mod)
    print("Frobenius matrix mod p^prec:")
    print(frob_matrix)
else:
    print("Warning: non-invertible elements encountered; check valuations.")

# Characteristic polynomial
poly = frob_matrix.characteristic_polynomial()
print("Characteristic polynomial (symbolically):", poly)

# Possibly reduce polynomial coefficients mod p^prec, adjusting if > p^(prec)//2
reduced_poly = _sage_const_0 
for mono in poly.monomials():
    c = poly.monomial_coefficient(mono) % (p**prec)
    # Adjust sign if you like symmetrical reps
    if c >= (p**prec)//_sage_const_2 :
        c = c - p**prec
    reduced_poly += c * mono

print("Reduced characteristic polynomial:", reduced_poly)
print("Prime p:", p)
print("Dimension of Pn:", size_pn)

